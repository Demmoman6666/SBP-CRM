// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Customer {
  id                   String    @id @default(cuid())
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  salonName            String
  customerName         String
  addressLine1         String
  addressLine2         String?
  town                 String?
  county               String?
  postCode             String?
  daysOpen             String?
  brandsInterestedIn   String?
  notes                String?
  salesRep             String?
  customerNumber       String?
  customerTelephone    String?
  customerEmailAddress String?
  openingHours         String?
  numberOfChairs       Int?

  visits               Visit[]
  notesLog             Note[]
  callLogs             CallLog[]

  // ── Shopify sync fields (Step 2)
  shopifyCustomerId    String?   @unique
  shopifyTags          String[]  @default([])
  shopifyLastSyncedAt  DateTime?

  // Orders relationship (sales data)
  orders               Order[]

  @@index([customerEmailAddress])
}

model Visit {
  id               String    @id @default(cuid())
  customerId       String
  customer         Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)

  date             DateTime  @default(now())
  startTime        DateTime?
  endTime          DateTime?
  durationMinutes  Int?

  summary          String?
  staff            String?

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([customerId, date])
}

model Note {
  id          String    @id @default(cuid())
  customerId  String
  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)

  text        String
  staff       String?
  createdAt   DateTime  @default(now())

  @@index([customerId, createdAt])
}

model SalesRep {
  id        String   @id @default(cuid())
  name      String   @unique
  email     String?
  createdAt DateTime @default(now())

  // Optional: reverse relation for tag rules
  tagRules  SalesRepTagRule[]
}

model Brand {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
}

model CallLog {
  id                 String   @id @default(cuid())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  isExistingCustomer Boolean

  customerId         String?
  customer           Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  customerName       String?
  contactPhone       String?
  contactEmail       String?

  callType           String?
  summary            String?
  outcome            String?
  staff              String?

  followUpRequired   Boolean   @default(false)
  followUpAt         DateTime?

  // call timing fields
  startTime          DateTime?
  endTime            DateTime?
  durationMinutes    Int?
  appointmentBooked  Boolean?  @default(false)

  @@index([createdAt])
  @@index([isExistingCustomer, customerId])
}

// Separate table for stocked brands (distinct from competitor Brand)
model StockedBrand {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
model Order {
  id                 String     @id @default(cuid())
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt

  // Shopify identifiers
  shopifyOrderId     String?    @unique
  shopifyOrderNumber Int?
  shopifyName        String?    // e.g. "#1001"

  // Customer link
  customerId         String?
  customer           Customer?  @relation(fields: [customerId], references: [id], onDelete: SetNull)

  // Timestamps & status
  processedAt        DateTime?
  currency           String?
  financialStatus    String?
  fulfillmentStatus  String?

  // Money (Decimal for currency safe math)
  subtotal           Decimal?   @db.Decimal(12, 2)
  total              Decimal?   @db.Decimal(12, 2)
  taxes              Decimal?   @db.Decimal(12, 2)
  discounts          Decimal?   @db.Decimal(12, 2)
  shipping           Decimal?   @db.Decimal(12, 2)

  lineItems          OrderLineItem[]

  @@index([customerId, processedAt])
}

model OrderLineItem {
  id                String   @id @default(cuid())
  orderId           String
  order             Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Shopify identifiers
  shopifyLineItemId String?  @unique
  productId         String?
  productTitle      String?
  variantId         String?
  variantTitle      String?
  sku               String?

  quantity          Int      @default(1)
  price             Decimal? @db.Decimal(12, 2) // unit price
  total             Decimal? @db.Decimal(12, 2) // quantity * price (optional cache)

  createdAt         DateTime @default(now())

  @@index([orderId])
}

// Tag → Sales Rep mapping (e.g., tag "Alex" => rep Alex Krizan)
model SalesRepTagRule {
  id          String   @id @default(cuid())
  tag         String   @unique
  salesRepId  String
  salesRep    SalesRep @relation(fields: [salesRepId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
}

// Singleton-style row to track last sync cursors / timestamps
model ShopifySyncState {
  id                       Int      @id @default(1)
  lastCustomersSyncedAt    DateTime?
  lastOrdersSyncedAt       DateTime?
  lastWebhookReceivedAt    DateTime?
  updatedAt                DateTime @updatedAt
}

// Optional: store raw webhook payloads for debugging/auditing
model WebhookLog {
  id        String   @id @default(cuid())
  topic     String
  shopifyId String?
  payload   Json
  createdAt DateTime @default(now())

  @@index([topic, createdAt])
}
